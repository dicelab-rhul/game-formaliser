###PROMPT##
The following is a Prolog program that can be used to generate and test all legal evolutions of a game represented in the situation calculus:

% All legal evolutions of a game: can be used both as a generator and test.
game(F,F):- final(F).  
game(S,F):- \+ final(S), legal(M,S), game(do(M,S),F).


The domain independent version of the situation calculus is as follows:

% Situation Calculus - our formulation for games.
holds(F, S):- initially(F, S).
holds(F, do(M, S)):- effect(F, M, S).
holds(F, do(A, S)):- holds(F, S), \+ abnormal(F, A, S).

The prisoner's dilemma game, having the following verbal description:

"You play a game with an anonymous player in which you simultaneously make a choice. Your payoff depends on both choices. If you both pick C, you each get 3$. If you choose C while they choose D, you get 1$, and they get 4$. Similarly, if you pick D while they pick C, you get 4$, and they get 1$. If you both pick D, you each earn 2$. The game has only one round."

can be specified as follows:


/* Game specific predicates for Prisoner's Dilemma (PD) */

% Payoff matrix for PD
payoffPD('D', 'D', 2, 2).
payoffPD('C', 'D', 1, 4).
payoffPD('D', 'C', 4, 1).
payoffPD('C', 'C', 3, 3).

% Initial state
initial(s0).

% What holds initially: who is a player, their role, and whether they can play.	
initially(player(p1), s0).
initially(player(p2), s0).
initially(role(p1,row), s0).
initially(role(p2,col), s0).
initially(control(p1), s0).
initially(control(p2), s0).

% When a state is final: no need to check content as it generated by game/2,
% implying it is a legal state.
final(do(choice(_P2, _M2), do(choice(_P1, _M1), S))):-initial(S).

% A legal move is a possible move where the player has control (is its turn).
legal(choice(P, M), S):- possible(choice(P, M), S), holds(control(P), S).

% What is possible for a player to choose
possible(choice(P,'D'), S):- holds(player(P), S).
possible(choice(P,'C'), S):- holds(player(P), S).

% The effects of a move: if P has chosen M, then in the next state this
% is what they did.
effect(did(P, M), choice(P, M), _S).

% The effects of a move: once a choice is made, the player looses control, i.e.
% cannot move anymore.
abnormal(control(P), choice(P, _M), _S).

% What holds finally: the outcome with players, Moves, and Utilities.
finally(outcome(P1,M1,U1,P2,M2,U2), S):-
	final(S),
	holds(role(P1, row), S),	
	holds(did(P1, M1), S),	
	holds(role(P2, col), S),	
	holds(did(P2, M2), S),
	payoffPD(M1, M2, U1, U2).

% Goals achieved by the players.
finally(goal(P1, U1), S):-
	finally(outcome(P1,_,U1,_,_,_), S).
finally(goal(P2, U2), S):-
	finally(outcome(_,_,_,P2,_,U2), S).
	
The verbal decription of another game is as follows:

Two rival political candidates must decide whether to engage in mudslinging during their campaign. If both engage in mudslinging, they degrade the political discourse and might turn off voters, each receiving a payoff of 3. If one mudslings and the other runs a clean campaign, the mudslinger might tarnish the opponent's reputation and win more votes, receiving a payoff of 8, while the clean campaigner receives a payoff of 2. If neither engages in mudslinging, they uphold higher moral standards but miss the opportunity to undermine their opponent, each candidates getting a payoff of 5.

Produce set of domain specific axioms for the game. Use numerical payoffs. Mark the beginning and end of the code with a '@'. Write code compatible with SWI Prolog. If the clauses of a specified predicate are not together in the source file, use the discontiguous declaration of SWI:

:- discontiguous p/3.

 at the beginning of the file.

###ATTEMPT##0~
RESPONSE##
Sure, here is the code for the new game "Rival Political Candidates" represented in the situation calculus for Prolog, compatible with SWI-Prolog:

```prolog
% Ensure compatibility with SWI-Prolog
:- discontiguous initial/1.
:- discontiguous final/1.
:- discontiguous legal/2.
:- discontiguous possible/2.
:- discontiguous effect/3.
:- discontiguous abnormal/3.
:- discontiguous initially/2.
:- discontiguous payoffRival/6.
:- discontiguous finally/2.
:- discontiguous finally/3.

@  
/* Game specific predicates for Rival Political Candidates */

% Payoff matrix for Rival Political Candidates
payoffRival('M', 'M', 3, 3).
payoffRival('C', 'M', 2, 8).
payoffRival('M', 'C', 8, 2).
payoffRival('C', 'C', 5, 5).

% Initial state
initial(s0).

% What holds initially: who is a player, their role, and whether they can play.
initially(player(c1), s0).
initially(player(c2), s0).
initially(role(c1,row), s0).
initially(role(c2,col), s0).
initially(control(c1), s0).
initially(control(c2), s0).

% When a state is final: no need to check content as it generated by game/2,
% implying it is a legal state.
final(do(choice(_C2, _M2), do(choice(_C1, _M1), S))):-initial(S).

% A legal move is a possible move where the player has control (it's their turn).
legal(choice(C, M), S):- possible(choice(C, M), S), holds(control(C), S).

% What is possible for a player to choose
possible(choice(C,'M'), S):- holds(player(C), S).
possible(choice(C,'C'), S):- holds(player(C), S).

% The effects of a move: if C has chosen M, then in the next state this
% is what they did.
effect(did(C, M), choice(C, M), _S).

% The effects of a move: once a choice is made, the player loses control, i.e.,
% cannot move anymore.
abnormal(control(C), choice(C, _M), _S).

% What holds finally: the outcome with players, Moves, and Utilities.
finally(outcome(C1,M1,U1,C2,M2,U2), S):-
	final(S),
	holds(role(C1, row), S),	
	holds(did(C1, M1), S),	
	holds(role(C2, col), S),	
	holds(did(C2, M2), S),
	payoffRival(M1, M2, U1, U2).

% Goals achieved by the players.
finally(goal(C1, U1), S):-
	finally(outcome(C1,_,U1,_,_,_), S).
finally(goal(C2, U2), S):-
	finally(outcome(_,_,_,C2,_,U2), S).
@

```

This code uses the same structure as the initial "Prisoner's Dilemma" example. The payoff matrix and the other required predicates are defined in accordance with the verbal description of the "Rival Political Candidates" game. The `payoffRival/6` predicate is used to map the choices of the two players to their respective payoffs. This code should be compatible with SWI-Prolog when used as part of a program that utilizes the situation calculus to model game evolutions.~

TRACE##
~

